//Generation 1&2
//The GB Games

//JPGreen (gen 0)
//Red/Blue/Yellow
//Gold/Silver/Crystal

//Unlike later games, the GB games have no encryption or checksums
//Which makes working with them relatively easy

#include <stdint.h>
#include <string.h>
#include "checksum.h"
#include "types.h"
#include "game_gb.h"

//TODO find a better table, we need both english and japanese for this
/**
 * The PK and MN symbols use lower case pi and mu respectively.
 */
static const uint16_t gb_to_codepage[] = {
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0x0000, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x0020,
	0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048,
	0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, 0x0050,
	0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058,
	0x0059, 0x005a, 0x0028, 0x0029, 0x003a, 0x003b, 0x005b, 0x005d,
	0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068,
	0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, 0x0070,
	0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078,
	0x0079, 0x007a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0x03c0, 0x03bc, 0x002d, 0xffff, 0xffff, 0x003f, 0x0021,
	0x002e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	0xffff, 0x00d7, 0xffff, 0x002f, 0x002c, 0xffff, 0x0030, 0x0031,
	0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039,
};

enum {
	GB_PROTECTED_START = 0x2598,
	GB_PROTECTED_LENGTH = 0xf8b,
	GB_CHECKSUM = 0x3523,
	GB_CODEPAGE_SIZE = 0x100
};

void gb_text_to_ucs2(char16_t *dst, char8_t *src, size_t size) {
	for(int i = 0; i < size; ++i) {
		dst[i] = gb_to_codepage[src[i]];
	}
}

void ucs2_to_gb_text(char8_t *dst, char16_t *src, size_t size) {
	bool ended = false;
	for(int i = 0; i < size; ++i) {
		//go through the table and find the matching symbol for src[i]
		if(ended) {
			dst[i] = 0x50;
		}
		dst[i] = 0xE6; //question mark by default
		for(int j = 0; j < GB_CODEPAGE_SIZE; ++j) {
			if(gb_to_codepage[j] == src[i]) {
				dst[i] = gb_to_codepage[j];
				if(!src[i]) {
					ended = true;
				}
				break;
			}
		}
	}
}


gb_save_t *gb_read_save(const uint8_t *ptr) {
	gb_save_t *save = malloc(sizeof(gb_save_t));
	save->data = malloc(GB_SAVE_SIZE);
	memcpy(save->data, ptr, GB_SAVE_SIZE);
	return save;
}

void gb_free_save(gb_save_t *sav) {
	//SIGTRAP OCCURING HERE?
	free(sav->data);
	sav->data = NULL;
	free(sav);
}

uint8_t *gb_create_data() {
	return malloc(GB_SAVE_SIZE);
}

void gb_write_save(uint8_t *ptr, const gb_save_t *save) {
	memcpy(ptr, save->data, GB_SAVE_SIZE);
	//calculate checksum, then write it to where it goes in ptr
	ptr[GB_CHECKSUM] = gb_checksum(ptr + GB_PROTECTED_START, GB_PROTECTED_LENGTH);
}
